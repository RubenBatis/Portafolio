<! DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
			<title>3D Model Viewer with Thumbnails</title>
			<link rel="stylesheet" href="styles.css">
	</head>
	<body>
		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
					"OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js",
					"GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/GLTFLoader.js",	
					"STLLoader": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/STLLoader.js"
				}
			}
		</script>

		<script type="module">
			import * as THREE from 'three';
			import { OrbitControls } from 'OrbitControls';
			import { GLTFLoader } from 'GLTFLoader';
			import { STLLoader } from 'STLLoader';
			
			
			// Crear la escena y el renderer
			var scene = new THREE.Scene();
			var renderer = new THREE.WebGLRenderer({ antialias: true });
			document.body.appendChild(renderer.domElement);
			
			// Función para configurar el tamaño del canvas y renderer
			function resizeRendererToDisplaySize() {
				const width = window.innerWidth;
				const height = window.innerHeight * 0.8;

				renderer.setSize(width * 2, height * 2, false);
				renderer.domElement.style.width = width + 'px';
				renderer.domElement.style.height = height + 'px';
			}
			
			//Ajustar el tamaño del renderer
			renderer.setSize(window.innerWidth * 2, window.innerHeight * 2);
			renderer.domElement.style.width = window.innerWidth + 'px';
			renderer.domElement.style.height = (window.innerHeight * 0.8) + 'px';

			var canvas = renderer.domElement;
			
			async function setupCamera() {
				// Esperamos hasta que el canvas tenga un tamaño mayor que 0
				while (canvas.clientWidth === 0 || canvas.clientHeight === 0) {
					console.log("Esperando que el canvas tenga dimensiones...");
					await new Promise(resolve => setTimeout(resolve, 100)); // Esperar 100ms antes de verificar de nuevo
				}

				// Ahora que el canvas tiene dimensiones válidas, podemos configurar la cámara
				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
				return camera;
			}
			
			//var camera = setupCamera();
			
			let camera;
			let controls;
			
			setupCamera().then((cam) => {
				camera = cam;
				scene.add(camera);

				// Añadir controles de órbita
				controls = new OrbitControls(camera, renderer.domElement);
				controls.enableDamping = true; // Suaviza el movimiento
				controls.dampingFactor = 0.25;
				controls.enableZoom = true;

				controls.mouseButtons = {
					LEFT: THREE.MOUSE.ROTATE,    // Mantén el botón izquierdo para rotar
					MIDDLE: null,                // Desactiva el botón central (rueda)
					RIGHT: THREE.MOUSE.PAN       // Mantén el botón derecho para hacer pan
				};

				// Aquí puedes configurar otras propiedades iniciales o llamar a funciones de la cámara o los controles
			}).catch(error => console.log("Error al configurar la cámara:", error));
			
			//renderer.setSize(window.innerWidth, window.innerHeight * 0.8);
			
			
			
			// Añadir iluminación fija
			var ambientLight = new THREE.AmbientLight(0x404040); // Luz ambiental
			scene.add(ambientLight);
			
			//Animación
			let mixers = {};
			const clock = new THREE.Clock();
			
			let modelNames = [];
			let modelConfigs = {};
			let models = {};
			let animations = {};
			
			//scene.add(camera);
			
			function saveModelConfig(modelName) {
				modelConfigs[modelName].camera.position = [camera.position.x, camera.position.y, camera.position.z];
			}
			
			function updateThumbnailsBackground(backgroundColor) {
				const thumbnailsDiv = document.querySelector("#thumbnail-container");

				if (thumbnailsDiv) {
					thumbnailsDiv.style.background = `linear-gradient(${backgroundColor}, transparent)`;
				}
			}
			
			function updateModelDescription(description, backgroundColor) {
				const descriptionDiv = document.querySelector("#description-panel");
				
				if (descriptionDiv) {
					descriptionDiv.innerHTML = description.replace(/\n/g, '<br>');
					descriptionDiv.style.color = backgroundColor;
					document.getElementById("toggle-button").style.color = backgroundColor;
				}
			}

			// Funciones para limpiar la escena
			function disposeNode(node) {
				if (node.geometry) {
					node.geometry.dispose();
				}

				if (node.material) {
					if (Array.isArray(node.material)) {
						node.material.forEach(material => material.dispose());
					} else {
						node.material.dispose();
					}
				}

				if (node.texture) {
					node.texture.dispose();
				}
			}

			function clearScene(scene) {
				while(scene.children.length > 0){ 
					let object = scene.children[0];
					scene.remove(object);
					if (object.geometry) object.geometry.dispose(); // Liberar geometría
					if (object.material) {
						if (Array.isArray(object.material)) {
							object.material.forEach(mat => mat.dispose());
						} else {
							object.material.dispose(); // Liberar materiales
						}
					}
				}
			}

			function applyModelConfig(modelName) {
				const config = modelConfigs[modelName];
				// Eliminar todos los elementos de la escena
				clearScene(scene);
				
				// Y volver a cargar el modelo en cuestión
				let model = models[modelName];
				scene.add(model);			
				
				// Cambiar el color de fondo de la escena 3D
				scene.background = new THREE.Color(config.backgroundColor);
				//renderer.setClearColor(0x000000, 0); //Esto pone el fondo transparente
				
				// Configuración de la cámara
				if (config.camera) {
					const cameraPosition = config.camera.position;
					const cameraRotation = config.camera.rotation;
					const cameraLookAt = config.camera.lookAt;
					const cameraZoom = config.camera.zoom || 1;

					camera.position.set(cameraPosition[0], cameraPosition[1], cameraPosition[2]);
					camera.rotation.set(cameraRotation[0], cameraRotation[1], cameraRotation[2]);
					controls.target.set(cameraLookAt[0], cameraLookAt[1], cameraLookAt[2]);
					controls.update();
					camera.zoom = cameraZoom;
					camera.updateProjectionMatrix();  // Esto es necesario después de ajustar el zoom
				}
				
				// Añadir nuevas luces desde la configuración
				config.lights.forEach(lightConfig => {
					const light = new THREE.DirectionalLight(lightConfig.color, lightConfig.intensity);
					light.position.set(lightConfig.position[0], lightConfig.position[1], lightConfig.position[2]);
					scene.add(light);

					if (!scene.lights) {
						scene.lights = [];
					}
					scene.lights.push(light);
				});

				// Configurar luz ambiental si está definida
				if (config.ambientLight) {
					const ambientLight = new THREE.AmbientLight(config.ambientLight.color, config.ambientLight.intensity);
					scene.add(ambientLight);
				}

				// Cambiar el color del degradado de fondo en los thumbnails
				updateThumbnailsBackground(config.backgroundColor);

				// Mostrar la descripción en el HTML
				updateModelDescription(config.description, config.backgroundColor);
			}

			// Cargar modelos 3D
			var gltfLoader = new GLTFLoader();
			var stlLoader = new STLLoader();
			var currentModelIndex = 0;

			async function checkFileExists(url) {
				return new Promise((resolve) => {
					var xhr = new XMLHttpRequest();
					xhr.open('HEAD', url, true);
					xhr.onload = function() {
						resolve(xhr.status != 404);
					};
					xhr.send();
				});
			}
			
			// Crear contenedor de miniaturas
			var thumbnailContainer = document.createElement('div');
			thumbnailContainer.id = 'thumbnail-container';
			document.body.appendChild(thumbnailContainer);
			
			async function loadModel(modelFile) {
				return new Promise((resolve, reject) => {
					const loader = new GLTFLoader();
					loader.load(modelFile, function (gltf) {
						let modelName = modelFile.split('/').pop().split('.').slice(0, -1).join('.');
						models[modelName] = gltf.scene;
						animations[modelName] = gltf.animations;
						// Si el modelo tiene animaciones, configurarlas
						if (gltf.animations && gltf.animations.length > 0) {
							mixers[modelName] = new THREE.AnimationMixer(gltf.scene);  // Crea un mixer de animación
							gltf.animations.forEach((clip) => {
								const action = mixers[modelName].clipAction(clip);
								action.loop = THREE.LoopRepeat;  // Configura la animación en bucle
								action.play();  // Reproduce la animación
							});
						}
						resolve();
					}, undefined, function (error) {
						console.error(`Error al cargar el modelo: ${error}`);
						reject();
					});
				});
			}
			
			function loadThumbnail(thumbnailFile) {
				const thumbnailElement = document.createElement('img');
				thumbnailElement.className = "thumbnail";
				thumbnailElement.src = thumbnailFile;
				thumbnailElement.onerror = function(){
					this.onerror = null;
					this.src = "models/not_found.png";
				}
				thumbnailElement.setAttribute("data-thumbnumber", document.querySelectorAll('#thumbnail-container .thumbnail').length);
				thumbnailElement.addEventListener('click', (event) => {
					saveModelConfig(modelNames[currentModelIndex]);
					currentModelIndex = Number(event.currentTarget.dataset.thumbnumber);
					applyModelConfig(modelNames[currentModelIndex]);
					updateThumbnails();
					console.log(scene);
				});
				document.getElementById('thumbnail-container').appendChild(thumbnailElement);
			}
			
			async function listJSONFiles() {
				try {
					const response = await fetch('/models');
					if (!response.ok) {
						throw new Error('Network response was not ok');
					}
					const jsonFiles = await response.json();
					return jsonFiles;
				} catch (error) {
					console.error('Error fetching models:', error);
				}
			}
			
			async function loadModelsFromJSON() {
				const modelFolder = '/models'; // Ruta de la carpeta donde están los JSON
				
				try {
					// Espera a que se resuelva la promesa que devuelve los archivos JSON
					const jsonFiles = await listJSONFiles(); 

					// Asegúrate de que jsonFiles tiene contenido
					if (jsonFiles && jsonFiles.length > 0) {
						const promises = jsonFiles.map(async (jsonFile) => {
						//jsonFiles.forEach(async (jsonFile) => {
							try {
								const response = await fetch(`${modelFolder}/${jsonFile}`);
								const config = await response.json();

								// Usar el archivo del modelo y thumbnail
								await loadModel(`${modelFolder}/${config.modelFile}`);
								loadThumbnail(`${modelFolder}/${config.thumbnailFile}`);
								const modelConfigName = config.modelFile.replace(/\.[^/.]+$/, "");
								modelConfigs[modelConfigName] = config;
								modelNames.push(modelConfigName);
							} catch (error) {
								console.error(`Error al cargar el JSON: ${error}`);
							}
						});
						
						await Promise.all(promises);
						//console.log("Todos los modelos cargados:", modelNames);
						
						if (modelNames.length > 0) {
							applyModelConfig(modelNames[0]);
						}
						
						
					} else {
						console.log('No se encontraron archivos JSON.');
					}
				} catch (error) {
					console.error('Error al cargar modelos:', error);
				}
			}
			
			loadModelsFromJSON();

			// Añadir flechas de navegación
			var leftArrow = document.createElement('div');
			leftArrow.className = 'arrow left';
			leftArrow.innerHTML = "\u2329"; // Unicode para la flecha izquierda
			leftArrow.addEventListener('click', () => {
				saveModelConfig(modelNames[currentModelIndex])
				currentModelIndex = (currentModelIndex - 1 + modelNames.length) % modelNames.length;
				applyModelConfig(modelNames[currentModelIndex]);
				updateThumbnails();
			});
			thumbnailContainer.appendChild(leftArrow);

			var rightArrow = document.createElement('div');
			rightArrow.className = 'arrow right';
			rightArrow.innerHTML = "\u232A"; // Unicode para la flecha derecha
			rightArrow.addEventListener('click', () => {
				saveModelConfig(modelNames[currentModelIndex])
				currentModelIndex = (currentModelIndex + 1) % modelNames.length;
				applyModelConfig(modelNames[currentModelIndex]);
				updateThumbnails();
			});
			thumbnailContainer.appendChild(rightArrow);

			function updateThumbnails() {
				var thumbnails = document.querySelectorAll('.thumbnail');
				thumbnails.forEach((thumbnail, index) => {
					thumbnail.classList.remove('active');
					if (index === currentModelIndex) {
						thumbnail.classList.add('active');
					}
				});
			}

			// Desplazamiento cíclico de miniaturas
			thumbnailContainer.addEventListener('wheel', (event) => {
				if (event.deltaY > 0) {
					currentModelIndex = (currentModelIndex + 1) % modelNames.length;
				} else {
					currentModelIndex = (currentModelIndex - 1 + modelNames.length) % modelNames.length;
				}
					applyModelConfig(modelNames[currentModelIndex]);
					updateThumbnails();
				}, { passive: true });

			// Crear y añadir el panel de descripción
			var descriptionPanel = document.createElement('div');
			descriptionPanel.id = 'description-panel';
			descriptionPanel.style.display = 'none';
			document.body.appendChild(descriptionPanel);

			// Crear y añadir el botón de mostrar/ocultar
			var toggleButton = document.createElement('button');
			toggleButton.id = 'toggle-button';
			toggleButton.innerText = '\u2261';
			toggleButton.addEventListener('click', () => {
				if (descriptionPanel.style.display === 'none') {
					descriptionPanel.style.display = 'block';
					panel.offsetHeight;
					panel.style.filter = 'invert(100%)'
				} else {
					descriptionPanel.style.display = 'none';
				}
			});
			document.body.appendChild(toggleButton);
			
			// Animar la escena
			function animate() {
				requestAnimationFrame(animate);
				resizeRendererToDisplaySize();
				let mixer = mixers[modelNames[currentModelIndex]];
				// Si hay un mixer activo, actualizarlo
				if (mixer) {
					const delta = clock.getDelta();  // Usamos delta para actualizar el mixer
					mixer.update(delta);  // Actualizamos el mixer
				}
				if (controls) {
					controls.update(); // Actualizar los controles
				}
				if (camera) {
					// Actualizar la relación de aspecto de la cámara si cambia el tamaño del renderer
					camera.aspect = renderer.domElement.clientWidth / renderer.domElement.clientHeight;
					camera.updateProjectionMatrix();
					renderer.render(scene, camera);
				}
			}

			animate();
		</script>
	</body>
</html>
