<! DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
			<title>3D Model Viewer with Thumbnails</title>
			<link rel="stylesheet" href="styles.css">
</head>
			<body>
				<script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
        "OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js",
        "GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/GLTFLoader.js",	
        "STLLoader": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/STLLoader.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'OrbitControls';
    import { GLTFLoader } from 'GLTFLoader';
    import { STLLoader } from 'STLLoader';
	
    // Crear la escena
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    var renderer = new THREE.WebGLRenderer({ antialias: true });
    //renderer.setSize(window.innerWidth, window.innerHeight * 0.8);
	renderer.setSize(window.innerWidth * 2, window.innerHeight * 2);
	renderer.domElement.style.width = window.innerWidth + 'px';
	renderer.domElement.style.height = (window.innerHeight * 0.8) + 'px';
    document.body.appendChild(renderer.domElement);
	
	// Variables para control de la luz
	var lightPosition = { theta: Math.PI / 4, phi: Math.PI / 4 }; // Ángulos iniciales de la luz
	var radius = 5; // Distancia de la luz al origen (0, 0, 0)
	var draggingLight = false; // Bandera para saber si estamos arrastrando la luz
	var lastMousePosition = { x: 0, y: 0 };
	const maxLightIntensity = 5;
	
	// Añadir iluminación fija
    var ambientLight = new THREE.AmbientLight(0x404040); // Luz ambiental
    scene.add(ambientLight);

	// Añadir iluminación direccional
    var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
	directionalLight.position.set(5, 5, 5);
	scene.add(directionalLight);
	
	//Animación
	let mixer;
	const clock = new THREE.Clock();
	
	const modelConfigs = {};
	let modelNames = [];
	let models = {};
	
	function saveModelConfig(modelName) {
		modelConfigs[modelName].camera.position = [camera.position.x, camera.position.y, camera.position.z];
		//modelConfigs[modelName].camera.rotation ...
		//modelConfigs[modelName].lights = directionalLights;
		modelConfigs[modelName].lights = scene.lights;
		/*
		modelConfigs[modelName] = {
		    description: modelConfigs[modelName].description,
			cameraPosition: {
				x: camera.position.x,
				y: camera.position.y,
				z: camera.position.z
			},
			lightPosition: {
				x: directionalLight.position.x,
				y: directionalLight.position.y,
				z: directionalLight.position.z
			},
			lightIntensity: directionalLight.intensity
		};*/
	}
	
	function updateThumbnailsBackground(backgroundColor) {
		const thumbnailsDiv = document.querySelector("#thumbnail-container");

		if (thumbnailsDiv) {
			thumbnailsDiv.style.background = `linear-gradient(${backgroundColor}, transparent)`;
		}
	}
	
	function updateModelDescription(description) {
		const descriptionDiv = document.querySelector("#description-panel");

		if (descriptionDiv) {
			descriptionDiv.textContent = description;
		}
	}

	// Funciones para limpiar la escena
	function disposeNode(node) {
		if (node.geometry) {
			node.geometry.dispose();
		}

		if (node.material) {
			if (Array.isArray(node.material)) {
				node.material.forEach(material => material.dispose());
			} else {
				node.material.dispose();
			}
		}

		if (node.texture) {
			node.texture.dispose();
		}
	}

	function clearScene(scene) {
		while(scene.children.length > 0){
			disposeNode(scene.children[0]);
			scene.remove(scene.children[0]); 
		}
	}

	function applyModelConfig(modelName) {
		const config = modelConfigs[modelName];
		// Eliminar todos los elementos de la escena
		clearScene(scene);
		
		// Y volver a cargar el modelo en cuestión
		scene.add(models[modelName]);
		
		// Cambiar el color de fondo de la escena 3D
		scene.background = new THREE.Color(config.backgroundColor);
		//renderer.setClearColor(0x000000, 0); //Esto pone el fondo transparente
		
		// Configuración de la cámara
		if (config.camera) {
			const cameraPosition = config.camera.position;
			const cameraRotation = config.camera.rotation;
			const cameraZoom = config.camera.zoom || 1;

			camera.position.set(cameraPosition[0], cameraPosition[1], cameraPosition[2]);
			camera.rotation.set(cameraRotation[0], cameraRotation[1], cameraRotation[2]);
			camera.zoom = cameraZoom;
			camera.updateProjectionMatrix();  // Esto es necesario después de ajustar el zoom
		}

		// Eliminar luces anteriores
		//while (scene.lights && scene.lights.length) {
		//	const light = scene.lights.pop();
		//	scene.remove(light);
		//}
		
		// Añadir nuevas luces desde la configuración
		config.lights.forEach(lightConfig => {
			const light = new THREE.DirectionalLight(lightConfig.color, lightConfig.intensity);
			light.position.set(lightConfig.position[0], lightConfig.position[1], lightConfig.position[2]);
			scene.add(light);

			if (!scene.lights) {
				scene.lights = [];
			}
			scene.lights.push(light);
		});

		// Configurar luz ambiental si está definida
		if (config.ambientLight) {
			const ambientLight = new THREE.AmbientLight(config.ambientLight.color, config.ambientLight.intensity);
			scene.add(ambientLight);
		}

		// Cambiar el color del degradado de fondo en los thumbnails
		updateThumbnailsBackground(config.backgroundColor);

		// Mostrar la descripción en el HTML
		updateModelDescription(config.description);
	}

	function resetToDefaultCameraAndLight() {
		camera.position.set(1, 1, 1); // Ajusta a tu valor por defecto
		directionalLight.position.set(1, 1, 1); // Ajusta a tu valor por defecto
		directionalLight.intensity = 1; // Ajusta a tu valor por defecto
		camera.lookAt(0, 0, 0);
		console.log('Configuración por defecto aplicada');
	}

	camera.add(directionalLight.target);

    // Añadir controles de órbita
    var controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // Suaviza el movimiento
    controls.dampingFactor = 0.25;
    controls.enableZoom = true;
	
	controls.mouseButtons = {
      LEFT: THREE.MOUSE.ROTATE,    // Mantén el botón izquierdo para rotar
      MIDDLE: null,                // Desactiva el botón central (rueda)
      RIGHT: THREE.MOUSE.PAN       // Mantén el botón derecho para hacer pan
	};

    camera.position.z = 2;
	camera.lookAt(new THREE.Vector3(0, 0, 0));	
	scene.add(camera);

    // Cargar modelos 3D
    var gltfLoader = new GLTFLoader();
    var stlLoader = new STLLoader();
    var thumbnailExtensions = ['.jpg', '.png', '.gif']; // Extensiones de miniaturas

    var currentModelIndex = 0;

	function updateLightPosition() {
	  var x = radius * Math.sin(lightPosition.phi) * Math.cos(lightPosition.theta);
	  var z = radius * Math.sin(lightPosition.phi) * Math.sin(lightPosition.theta);
	  var y = radius * Math.cos(lightPosition.phi);

	  directionalLight.position.set(x, y, z);
	}

	// Eventos del ratón en el canvas
	renderer.domElement.addEventListener('pointerdown', (event) => {
	  if (event.button === 1) {  // Rueda del ratón pulsada (button 1)
		draggingLight = true;
		lastMousePosition.x = event.clientX;
		lastMousePosition.y = event.clientY;
	  }
	});

	renderer.domElement.addEventListener('pointermove', (event) => {
	  if (draggingLight) {
		var deltaX = event.clientX - lastMousePosition.x;
		var deltaY = event.clientY - lastMousePosition.y;

		// Actualizar ángulos theta y phi basados en el movimiento del ratón
		lightPosition.theta -= deltaX * 0.005;  // Sensibilidad de movimiento horizontal
		lightPosition.phi -= deltaY * 0.005;    // Sensibilidad de movimiento vertical

		// Limitar el valor de phi para evitar invertir la luz
		lightPosition.phi = Math.max(0.1, Math.min(Math.PI - 0.1, lightPosition.phi));

		// Actualizar la posición de la luz
		updateLightPosition();

		lastMousePosition.x = event.clientX;
		lastMousePosition.y = event.clientY;
	  }
	});

	renderer.domElement.addEventListener('pointerup', (event) => {
	  if (event.button === 1) {  // Soltar la rueda del ratón
		draggingLight = false;
	  }
	});
	
	document.addEventListener('keydown', (event) => {
	  if (event.key === '+') {
		// Incrementa la intensidad de la luz
		directionalLight.intensity = Math.min(directionalLight.intensity + 0.1, maxLightIntensity); // Limita a un máximo de 5
		console.log("light adjusted to " + directionalLight.intensity + " for model: " + modelNames[currentModelIndex]);
	  } else if (event.key === '-') {
		// Disminuye la intensidad de la luz
		directionalLight.intensity = Math.max(directionalLight.intensity - 0.1, 0); // Limita a un mínimo de 0
		console.log("light adjusted to " + directionalLight.intensity + " for model: " + modelNames[currentModelIndex]);
	  }
	});

	// Llamamos una vez para posicionar la luz inicialmente
	updateLightPosition();

    async function checkFileExists(url) {
      return new Promise((resolve) => {
        var xhr = new XMLHttpRequest();
        xhr.open('HEAD', url, true);
        xhr.onload = function() {
          resolve(xhr.status != 404);
        };
        xhr.send();
      });
    }

/*
	function loadModelConfiguration(modelName) {
		const configPath = `config/${modelName}.json`;

		fetch(configPath)
			.then(response => response.json())
			.then(data => {
				applyModelConfiguration(data);
			})
			.catch(error => {
				console.error("Error loading model configuration: ", error);
			});
	}
	
	async function loadEverything() {
		try {
			const response = await fetch('/models');
			if (!response.ok) {
				throw new Error('Network response was not ok');
			}
			const data = await response.json();
			models = data;
			
			for (const [index, model] of models.entries()) {
				let thumbnailPath = 'models/not_found.png'; // Valor por defecto
				const modelName = `${model.replace(/\.[^/.]+$/, "")}`;
				defaultModelConfig(modelName); // Establecer la configuración por defecto
				
				// Cargar la descripción asíncronamente y actualizar el modelConfig
				try {
					const descriptionResponse = await fetch(`models/${modelName}.txt`);
					if (descriptionResponse.ok) {
						const description = await descriptionResponse.text();
						modelConfigs[modelName].description = description; // Actualizar descripción
					} else {
						console.warn(`No se pudo cargar el archivo ${modelName}.txt`);
					}
				} catch (error) {
					console.error(`Error al cargar el archivo ${modelName}.txt:`, error);
				}

				// Buscar la miniatura con las extensiones disponibles
				for (const extension of thumbnailExtensions) {
					const potentialPath = `models/${modelName + extension}`;
					const thumbExists = await checkFileExists(potentialPath);
					if (thumbExists) {
						thumbnailPath = potentialPath;
						break;
					}
				}

				// Crear el elemento img para la miniatura
				var img = document.createElement('img');
				img.src = thumbnailPath;
				img.className = 'thumbnail';
				if (index === currentModelIndex) {
					img.classList.add('active');
				}
				
				img.addEventListener('click', () => {
					saveModelConfig(`${modelNames[currentModelIndex].replace(/\.[^/.]+$/, "")}`);
					currentModelIndex = index;
					loadModel(currentModelIndex);
					updateThumbnails();
				});

				thumbnailContainer.appendChild(img);
			}

			// Cargar el primer modelo
			loadModel(currentModelIndex);
		} catch (error) {
			console.error('Error fetching models:', error);
		}
	}

    loadEverything();*/
	
	// Crear contenedor de miniaturas
    var thumbnailContainer = document.createElement('div');
    thumbnailContainer.id = 'thumbnail-container';
    document.body.appendChild(thumbnailContainer);
	
	async function loadModel(modelFile) {
		return new Promise((resolve, reject) => {
			const loader = new GLTFLoader();
			loader.load(modelFile, function (gltf) {
				let modelName = modelFile.split('/').pop().split('.').slice(0, -1).join('.');
				models[modelName] = gltf.scene;
				resolve();
			}, undefined, function (error) {
				console.error(`Error al cargar el modelo: ${error}`);
				reject();
			});
		});
	}
	
	function loadThumbnail(thumbnailFile) {
		const thumbnailElement = document.createElement('img');
		thumbnailElement.className = "thumbnail";
		thumbnailElement.src = thumbnailFile;
		thumbnailElement.onerror = function(){
			this.onerror = null;
			this.src = "models/not_found.png";
		}
		// Aquí agregarías la lógica para mostrar la imagen en la interfaz
		document.getElementById('thumbnail-container').appendChild(thumbnailElement);
	}
	
	async function listJSONFiles() {
		try {
			const response = await fetch('/models');
			if (!response.ok) {
				throw new Error('Network response was not ok');
			}
			const jsonFiles = await response.json();
			return jsonFiles;
		} catch (error) {
			console.error('Error fetching models:', error);
		}
	}
	
	async function loadModelsFromJSON() {
		const modelFolder = '/models'; // Ruta de la carpeta donde están los JSON
		
		try {
			// Espera a que se resuelva la promesa que devuelve los archivos JSON
			const jsonFiles = await listJSONFiles(); 

			// Asegúrate de que jsonFiles tiene contenido
			if (jsonFiles && jsonFiles.length > 0) {
				const promises = jsonFiles.map(async (jsonFile) => {
				//jsonFiles.forEach(async (jsonFile) => {
					try {
						const response = await fetch(`${modelFolder}/${jsonFile}`);
						const config = await response.json();

						// Usar el archivo del modelo y thumbnail
						await loadModel(`${modelFolder}/${config.modelFile}`);
						loadThumbnail(`${modelFolder}/${config.thumbnailFile}`);
						const modelConfigName = config.modelFile.replace(/\.[^/.]+$/, "");
						modelConfigs[modelConfigName] = config;
						modelNames.push(modelConfigName);
					} catch (error) {
						console.error(`Error al cargar el JSON: ${error}`);
					}
				});
				
				await Promise.all(promises);
				//console.log("Todos los modelos cargados:", modelNames);
				
				if (modelNames.length > 0) {
					applyModelConfig(modelNames[0]);
				}
				
				
			} else {
				console.log('No se encontraron archivos JSON.');
			}
		} catch (error) {
			console.error('Error al cargar modelos:', error);
		}
	}
	
	loadModelsFromJSON();

    // Añadir flechas de navegación
    var leftArrow = document.createElement('div');
    leftArrow.className = 'arrow left';
    leftArrow.innerHTML = "\u2329"; // Unicode para la flecha izquierda
    leftArrow.addEventListener('click', () => {
      saveModelConfig(modelNames[currentModelIndex])
      currentModelIndex = (currentModelIndex - 1 + modelNames.length) % modelNames.length;
      applyModelConfig(modelNames[currentModelIndex]);
      updateThumbnails();
    });
    thumbnailContainer.appendChild(leftArrow);

    var rightArrow = document.createElement('div');
    rightArrow.className = 'arrow right';
    rightArrow.innerHTML = "\u232A"; // Unicode para la flecha derecha
    rightArrow.addEventListener('click', () => {
	  saveModelConfig(modelNames[currentModelIndex])
      currentModelIndex = (currentModelIndex + 1) % modelNames.length;
      applyModelConfig(modelNames[currentModelIndex]);
      updateThumbnails();
    });
    thumbnailContainer.appendChild(rightArrow);

    function updateThumbnails() {
      var thumbnails = document.querySelectorAll('.thumbnail');
      thumbnails.forEach((thumbnail, index) => {
        thumbnail.classList.remove('active');
        if (index === currentModelIndex) {
          thumbnail.classList.add('active');
        }
      });
    }

    // Desplazamiento cíclico de miniaturas
    thumbnailContainer.addEventListener('wheel', (event) => {
      if (event.deltaY > 0) {
        currentModelIndex = (currentModelIndex + 1) % modelNames.length;
      } else {
        currentModelIndex = (currentModelIndex - 1 + modelNames.length) % modelNames.length;
      }
      applyModelConfig(modelNames[currentModelIndex]);
      updateThumbnails();
    }, { passive: true });

	// Crear y añadir el panel de descripción
    var descriptionPanel = document.createElement('div');
    descriptionPanel.id = 'description-panel';
	descriptionPanel.style.display = 'none';
    document.body.appendChild(descriptionPanel);

    // Crear y añadir el botón de mostrar/ocultar
    var toggleButton = document.createElement('button');
    toggleButton.id = 'toggle-button';
    toggleButton.innerText = 'Toggle Description';
    toggleButton.addEventListener('click', () => {
      if (descriptionPanel.style.display === 'none') {
        descriptionPanel.style.display = 'block';
      } else {
        descriptionPanel.style.display = 'none';
      }
    });
    document.body.appendChild(toggleButton);
	
    // Animar la escena
    function animate() {
      requestAnimationFrame(animate);
	  
	  // Si hay un mixer activo, actualizarlo
      if (mixer) {
          const delta = clock.getDelta();  // Usamos delta para actualizar el mixer
          mixer.update(delta);  // Actualizamos el mixer
      }
	  
      controls.update(); // Actualizar los controles
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>